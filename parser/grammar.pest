ws = _{ " " | "\n" | "\t" | "\r" } // Whitespace

alpha_lower = _{ 'a'..'z' }
alpha_upper = _{ 'A'..'Z' }
alpha = _{ alpha_lower | alpha_upper }
digit = _{ '0'..'9' }

//`a`: ok
//`a1`: ok
//`a_`: ok
//`_a`: ok
//`_`: ok
//`1`: error
//`A`: error # Identifiers are lowercase
ident = { (alpha_lower | "_") ~ (alpha_lower | digit | "_")* }

//`PI`: ok
//`A1`: ok
//`A_`: ok
//`_A`: ok
//`_`: ok
//`1`: error
//`a`: error # Constant identifiers are uppercase
constant_ident = { (alpha_upper | "_") ~ (alpha_upper | digit | "_")* }

//`90.0°`: ok, with `°` unit
//`5.0mm`: ok, with `mm` unit
//`90.0`: ok, no unit
//`mm`: error
number_literal = { number ~ unit? }

//`1.0`: ok
//`1`: ok
//`.1`: error
//`qwqeaq`: error
number = @{ ("-"? ~ int) ~ ("." ~ ASCII_DIGIT+ ~ exp? | exp)? }
int    = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
exp    = @{ ("E" | "e") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

//`"a"`: ok
//`"a\n"`: ok
//`"a\""`: ok
//`"hello{10}world": ok
format_string = { "\"" ~ string_literal_inner? ~ (format_expression ~ string_literal_inner?)* ~ "\"" }
string_literal_inner   = { (!("\"" | "\\" | "{" | "}" ) ~ ANY)* ~ ((bracket_escape | escape) ~ string_literal_inner)? }
bracket_escape = { "{{" | "}}" }
escape  = @{ "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t" | unicode) }
unicode = @{ "u" ~ ASCII_HEX_DIGIT{4} }

///`{a}`: ok
///`{a + b}`: ok
format_expression = { "{" ~ ws* ~ (format_option ~ ws* ~ ":" )? ~ ws* ~ expression ~ ws* ~ "}" }

///`05.5`: ok # Five leading zeros with 5 precision
format_option = { format_option_leading_zeros ~ format_option_precision | format_option_leading_zeros | format_option_precision }

//`.5`: print with precision = 5
format_option_precision = { "." ~ int }

//`05`: print with 5 leading zeros and precision = 0
format_option_leading_zeros = { "0" ~ int }

//`true`: ok
//`false`: ok
//`True`: error
//`False`: error
bool_literal = @{ "true" | "false" }

unit = @{ (alpha_lower)+ | "°" }

//`#FFF`: ok # RGB, single hex
//`#00FF00`: ok # RGB, double hex
//`#FFFF`: ok # RGBA, single hex
//`#00FF00FF`: ok # RGBA, double hex
//`#00FF0`: error # No valid color
color_literal = { "#" ~ (ASCII_HEX_DIGIT{8} | ASCII_HEX_DIGIT{6} | ASCII_HEX_DIGIT{4} | ASCII_HEX_DIGIT{3}) }

//`1`: ok
//`1mm`: ok
//`1.0mm`: ok
//`1.0`: ok
literal = { number_literal | bool_literal | color_literal }

//`a`: ok # Single identifier
//`a.b`: ok # Nested identifiers
//`a.b. c`: error # No whitespace between identifiers
//`a.b.c.`: error # No trailing dot
//`math.PI`: ok # Constant identifiers are allowed
//`PI`: ok # Single constant identifier
//`math.PI.PI`: ok # Nested constant identifiers (todo: check if this is allowed) 
qualified_name = { (ident | constant_ident) ~ ("." ~ (ident | constant_ident))* }
qualified_name_all = { "*" }
qualified_name_list = { qualified_name ~ ("," ~ ws* ~ qualified_name)* }

//`int`: ok
//`[scalar]`: ok # List type
type = { qualified_name | list_type | array_type }

//`[scalar]`: ok
//`[]`: ok # List with elements of arbitrary type
list_type = { "[" ~ ws* ~ type? ~ ws * ~ "]" }

//`my.array[1]`: ok
//`my.array[1][2]`: ok # two-dimensional array
array_type = { qualified_name ~ ws* ~ array_length+ }

//`[0]`: ok
//`[T]`: error # Must be a number
array_length = { "[" ~ ws* ~ int ~ ws* ~ "]" }

//`: scalar`: ok
//`: <Vec3>`: error
type_specifier = { ":" ~ ws* ~ type }

//`use a;`: ok  # Import a single module
//`use ;`: error # Must import at least one module
//`use foo.bar, bar.foo;`: ok # Import multiple modules
//`use bar, baz from a;`: ok # Import multiple sub modules from module a 
//`use * from a;`: ok # Import everything from a and merge into current scope
//`use * from a, b;`: ok # Import everything from a and b and merge into current scope
//`use a as b;`: ok # Import as alias
//`use a as b.a;`: error # Cannot use nested identifiers alias 
//`use foo.bar, bar.foo as baz;`: error # Alias is not supported for multiple modules
//`use foo.bar as baz from bar.foo;`: ok # Use alias for single module
use_statement = { "use" ~ ws+ ~ qualified_name_list ~ ws* ~ ";" 
    | "use" ~ ws+ ~ qualified_name_list ~ ws+ ~ "from" ~ ws+ ~ qualified_name ~ ws* ~ ";"
    | "use" ~ ws+ ~ qualified_name_all ~ ws+ ~ "from" ~ ws+ ~ qualified_name_list ~ ws* ~ ";"
    | "use" ~ ws+ ~ use_alias ~ ws* ~ ";"
    | "use" ~ ws+ ~ use_alias ~ ws+ ~ "from" ~ ws+ ~ qualified_name ~ ws* ~ ";" 
}
use_alias = { qualified_name ~ ws+ ~ "as" ~ ws+ ~ ident }

//`-5.0mm`: ok # Negate
//`(a+b)*(c-a)`: ok 
//`a + b + c`: ok 
//`! a`: ok # Unary operator with whitespace 
//`a-`: error # Unknown postfix operator `-`
expression       =   { unary_op* ~ ws* ~ primary ~ (ws* ~ bin_op ~ ws* ~ unary_op* ~ ws* ~ primary)* }
bin_op           =  _{ add | subtract | multiply | divide }
  add            =   { "+" }
  subtract       =   { "-" }
  multiply       =   { "*" }
  divide         =   { "/" }
unary_op         =  _{ unary_minus | unary_plus | unary_not }
  unary_minus    =   { "-" }
  unary_plus     =   { "+" }
  unary_not      =   { "!" }
primary  =  _{ literal | format_string | qualified_name | list_expression | "(" ~ expression ~ ")" }

//`[1, 2, 3]`: ok
//`[1, 2, 3,]`: error # Trailing comma
//`[]`: ok
list_expression = { "[" ~ (ws* ~ expression ~ ws* ~ ("," ~ ws* ~ expression ~ ws*)*)? ~ ws* ~ "]" }


unary_expression = { unary_operator ~ ws* ~ expression }
unary_operator = { "-" }

//`r = 5.0mm`: ok # Named argument
//`2.0mm`: ok # Positional argument
function_argument = { (ident ~ ws* ~ "=" ~ ws*)? ~ expression }

//`a = 5.0mm, b = false`: ok
function_argument_list = { function_argument ~ ws* ~ ("," ~ ws* ~ function_argument ~ ws*)* }

//`function(a = 3.0mm)`: ok
//`function(a = 3.0mm, b = 2.0mm)`: ok
//`a.nested.function(a = 3.0mm, b = 2.0mm)`: ok
function_call = { qualified_name ~ ws* ~ "(" ~ ws* ~ function_argument_list? ~ ws* ~ ")" }

//`r: length = 5.0mm`: ok
//`r = 5.0mm`: error # Type specifier is required, type inference is not supported yet
//`r: length`: ok # Default value is not required
//`r: length = math.PI`: ok # Constant value is allowed
parameter_declaration = { ident ~ ws* ~ type_specifier ~ ws* ~ ("=" ~ ws* ~ expression)? }

//`r: length = 5.0mm;`: ok
parameter_declaration_statement = { parameter_declaration ~ ws* ~ ";" }

//`function foo() -> scalar { return math.PI; }`: ok
//`function foo() -> scalar {}`: error # Function must have a return statement
//`function foo() { return 5.0mm; }`: error # Function must have specified return type
//`function foo(a: scalar) -> scalar { return a; }`: ok # Function with arguments
//`function foo(a: scalar, b: scalar) -> scalar { return b; }`: ok # Function with multiple arguments
function_declaration = { "function" ~ ws+ ~ ident ~ ws* ~ "(" ~ ws* ~ function_declaration_argument_list? ~ ws* ~ ")" ~ ws* ~ function_declaration_return_value ~ ws* ~ "{" ~ ws* ~ statement* ~ ws* ~ function_return_statement ~ ws* ~ "}" }

//`a: scalar`: ok
function_declaration_argument =  { parameter_declaration }

//`-> scalar`: ok
function_declaration_return_value = { "->" ~ ws* ~ type }

//`return 5.0mm;`: ok
function_return_statement = { "return" ~ ws* ~ expression ~ ws* ~ ";" }

//`a: scalar, b: scalar`: ok # Multiple arguments
//`a: scalar, b: scalar = 5.0mm`: ok # Default value for second argument
//`a: scalar = 5.0mm, b: scalar`: ok # Even first argument can have default value and rest can be positional
function_declaration_argument_list = { function_declaration_argument ~ ws* ~ ("," ~ ws* ~ function_declaration_argument ~ ws*)* }

//`module foo() { }`: ok # Module with no arguments
//`module foo(a: scalar) { }`: ok # Module with arguments
//`module foo(a: scalar, b: scalar) { }`: ok # Module with multiple arguments
//`module foo() { return 5.0mm; }`: error # Module cannot have return statement
//`module foo() { module bar() { } }`: ok # Nested module
//`module foo() { a: scalar = 5.0; function bar() -> scalar { return 1; } }`: ok # Parameter and nested function
//`module math { }`: ok # Module with no argument list acts as namespace
module_declaration = { "module" ~ ws+ ~ ident ~ ws* ~  
    module_declaration_argument_list? ~
    "{" ~ ws* ~ (statement ~ ws*)* ~ "}" }
module_declaration_argument_list = { ("(" ~ ws* ~ function_declaration_argument_list? ~ ws* ~ ")")? ~ ws* }

//`circle(r = 5.0mm);`: ok
//`circle(r = 5.0mm) {}`: ok
//`translate(x = 5.0mm) { rectangle(width = 5.0); }`: ok
//`translate(x = 5.0mm) { rotate(angle = 90°) { rectangle(width = 5.0mm); } }`: ok
//`translate(r = 5.0mm) circle(r = 5.0mm);`: ok
//`name := node() {}`: ok
//`name := node();`: ok
object_node_statement = { 
    object_node_id_assignment? ~ (function_call ~ ws*)+ ~ ";" |
    object_node_id_assignment? ~ (function_call ~ ws*)+ ~ "{" ~ object_node_inner ~ "}" 
}
object_node_id_assignment = { ident ~ ws* ~ ":=" ~ ws* }
object_node_inner = { ws* ~ (statement ~ ws*)* }

statement = { object_node_statement | use_statement | module_declaration | function_declaration | parameter_declaration_statement }

//`translate(x = 5.0mm) { rectangle(width = 5.0mm); } translate(x = 5.0mm) { rotate(angle = 90°) { rectangle(width = 5.0); } }`: ok
document = { SOI ~ (statement ~ ws* )* ~ EOI }

COMMENT = { doc_comment | single_line_comment | multi_line_comment }

//`// ok`: ok
//`/ err` error
single_line_comment = ${ "//" ~ (!"\n" ~ ANY)* }

//`/// ok`: ok
//`// err` error
doc_comment = { "///" ~ (!"\n" ~ ANY)* }

//`/* ok */`: ok
multi_line_comment = ${ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }