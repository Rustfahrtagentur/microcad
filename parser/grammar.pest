ws = _{ " " | "\n" | "\t" | "\r" } // Whitespace

alpha_lower = _{ 'a'..'z' }
alpha_upper = _{ 'A'..'Z' }
alpha = _{ alpha_lower | alpha_upper }
digit = _{ '0'..'9' }

//`a`: ok
//`a1`: ok
//`a_`: ok
//`_a`: ok
//`_`: ok
//`1`: error
//`A`: error # Identifiers are lowercase
ident = { (alpha_lower | "_") ~ (alpha_lower | digit | "_")* }

//`PI`: ok
//`A1`: ok
//`A_`: ok
//`_A`: ok
//`_`: ok
//`1`: error
//`a`: error # Constant identifiers are uppercase
constant_ident = { (alpha_upper | "_") ~ (alpha_upper | digit | "_")* }

//`90.0°`: ok, with `°` unit
//`5.0mm`: ok, with `mm` unit
//`90.0`: ok, no unit
//`mm`: error
number_literal = { number ~ unit? }

//`1.0`: ok
//`1`: ok
//`.1`: error
//`qwqeaq`: error
number = @{ ("-"? ~ int) ~ ("." ~ ASCII_DIGIT+ ~ exp? | exp)? }
int    = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
exp    = @{ ("E" | "e") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

//`"a"`: ok
//`"a\n"`: ok
//`"a\""`: ok
//`"hello{10}world": ok
format_string = { "\"" ~ string_literal_inner? ~ (format_expression ~ string_literal_inner?)* ~ "\"" }
string_literal_inner   = { (!("\"" | "\\" | "{" | "}" ) ~ ANY)* ~ ((bracket_escape | escape) ~ string_literal_inner)? }
bracket_escape = { "{{" | "}}" }
escape  = @{ "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t" | unicode) }
unicode = @{ "u" ~ ASCII_HEX_DIGIT{4} }

///`{a}`: ok
///`{a + b}`: ok
format_expression = { "{" ~ ws* ~ (format_spec ~ ws* ~ ":" )? ~ ws* ~ expression ~ ws* ~ "}" }

///`05.5`: ok # Five leading zeros with 5 precision
format_spec = { format_spec_leading_zeros ~ format_spec_precision | format_spec_leading_zeros | format_spec_precision }

//`.5`: print with precision = 5
format_spec_precision = { "." ~ int }

//`05`: print with 5 leading zeros and precision = 0
format_spec_leading_zeros = { "0" ~ int }

//`true`: ok
//`false`: ok
//`True`: error
//`False`: error
bool_literal = @{ "true" | "false" }

unit = @{ (alpha_lower)+ | "°" }

//`#FFF`: ok # RGB, single hex
//`#00FF00`: ok # RGB, double hex
//`#FFFF`: ok # RGBA, single hex
//`#00FF00FF`: ok # RGBA, double hex
//`#00FF0`: error # No valid color
color_literal = { "#" ~ (ASCII_HEX_DIGIT{8} | ASCII_HEX_DIGIT{6} | ASCII_HEX_DIGIT{4} | ASCII_HEX_DIGIT{3}) }

//`1`: ok
//`1mm`: ok
//`1.0mm`: ok
//`1.0`: ok
literal = { number_literal | bool_literal | color_literal }

//`a`: ok # Single identifier
//`a.b`: ok # Nested identifiers
//`a.b. c`: error # No whitespace between identifiers
//`a.b.c.`: error # No trailing dot
//`math.PI`: ok # Constant identifiers are allowed
//`PI`: ok # Single constant identifier
//`math.PI.PI`: ok # Nested constant identifiers (todo: check if this is allowed) 
qualified_name = { (ident | constant_ident) ~ ("." ~ (ident | constant_ident))* }
qualified_name_all = { "*" }
qualified_name_list = { qualified_name ~ ("," ~ ws* ~ qualified_name)* }

//`int`: ok
//`[scalar]`: ok # List type
//`(scalar, scalar)`: Tuple type
type = { qualified_name | list_type | tuple_type }

//`: scalar`: ok
//`: <Vec3>`: error
type_specifier = { ":" ~ ws* ~ type }

//`[scalar]`: ok list with elements of type `scalar`
//`[]`: ok # List with elements of arbitrary type
list_type = { "[" ~ ws* ~ (list_type_array | list_type_map | type)? ~ ws* ~ "]" }

// Array sub type of list type 
//`length;3`: ok # List with three elements of same type
//`4.0mm;2`: ok # List with two elements with default value 0.0mm
list_type_array = { (type | expression) ~ ws* ~ ";" ~ ws* ~ expression }

// Associative list, behaves like a map
//`length => string`: maps a length to a string
list_type_map = { type ~ ws* ~ "=>" ~ ws* ~ type }

//`[1, 2, 3]`: ok
//`[1, 2, 3,]`: error # Trailing comma
//`[]`: ok
list_expression = { "[" ~ ws* ~ expression_list? ~ ws* ~ "]" }

//`[0]`: ok # Access first element
//`["test"]`: ok # Associative lists, access value of `\"test\"`
list_element_access = { "[" ~ ws* ~ expression ~ ws* ~ "]" } 

//`(length,scalar)`: ok # 2 unnamed fields
//`(a: length, b = 4.0mm)`: ok # No default value for a, but for b
//`(length, a: length = 4.0mm)`: error # Cannot mix named and unnamed arguments
//`(a: length = 4.0mm, length)`: error # Unnamed argument followed by named argument
tuple_type = { "(" ~ ws* ~ (tuple_named_type_list | tuple_unnamed_type_list) ~ ws* ~ ")" }

//`length,scalar`: ok
//`length,`: error # Trailing comma
tuple_unnamed_type_list = { type ~ ws* ~ ("," ~ type)* }

//`r = 4.0mm, a: type = b, c: scalar`: ok
tuple_named_type_list = { variable_declaration ~ (ws* ~ "," ~ ws* ~ variable_declaration)* }

//`(1.0mm, 2.0mm)`: ok
//`(1.0mm,)`: error # Trailing comma
tuple_expression = { "(" ~ ws* ~ expression_list ~ ws* ~ ")" }

//`.0`: ok
//`.height`: ok
//`.=`: error # Neither an identifier nor an integer
tuple_element_access = { "." ~ ws* ~ (ident | int) }

//`use a;`: ok  # Import a single module
//`use ;`: error # Must import at least one module
//`use foo.bar, bar.foo;`: ok # Import multiple modules
//`use bar, baz from a;`: ok # Import multiple sub modules from module a 
//`use * from a;`: ok # Import everything from a and merge into current scope
//`use * from a, b;`: ok # Import everything from a and b and merge into current scope
//`use a as b;`: ok # Import as alias
//`use a as b.a;`: error # Cannot use nested identifiers alias 
//`use foo.bar, bar.foo as baz;`: error # Alias is not supported for multiple modules
//`use foo.bar as baz from bar.foo;`: ok # Use alias for single module
use_statement = { "use" ~ ws+ ~ qualified_name_list ~ ws* ~ ";" 
    | "use" ~ ws+ ~ qualified_name_list ~ ws+ ~ "from" ~ ws+ ~ qualified_name ~ ws* ~ ";"
    | "use" ~ ws+ ~ qualified_name_all ~ ws+ ~ "from" ~ ws+ ~ qualified_name_list ~ ws* ~ ";"
    | "use" ~ ws+ ~ use_alias ~ ws* ~ ";"
    | "use" ~ ws+ ~ use_alias ~ ws+ ~ "from" ~ ws+ ~ qualified_name ~ ws* ~ ";" 
}
use_alias = { qualified_name ~ ws+ ~ "as" ~ ws+ ~ ident }

//`-5.0mm`: ok # Negate
//`(a+b)*(c-a)`: ok 
//`a + b + c`: ok 
//`! a`: ok # Unary operator with whitespace 
//`a-`: error # Unknown postfix operator `-`
expression       =   { unary_op* ~ ws* ~ primary ~ (ws* ~ bin_op ~ ws* ~ unary_op* ~ ws* ~ primary)* }
bin_op           =  _{ add | subtract | multiply | divide }
  add            =   { "+" }
  subtract       =   { "-" }
  multiply       =   { "*" }
  divide         =   { "/" }
unary_op         =  _{ unary_minus | unary_plus | unary_not }
  unary_minus    =   { "-" }
  unary_plus     =   { "+" }
  unary_not      =   { "!" }
primary  =  _{ literal | format_string | qualified_name | list_expression | "(" ~ expression ~ ")" }

//`a, b, c`: ok
//`1+2, 4*3, 3.2`: ok
//`,,`: error # No expression 
expression_list = { expression ~ (ws* ~ "," ~ ws* ~ expression)* }

//`1..4`: ok
//`a..b`: ok
range_expression = { expression ~ ws* ~ ".." ~ ws* ~ expression }

unary_expression = { unary_operator ~ ws* ~ expression }
unary_operator = { "-" }

//`= 4.0mm`: ok
//`= `: error # No expression
//`= 1 + 2`: ok
default_value = { "=" ~ ws* ~ expression }

//`r = 5.0mm`: ok # Named argument
function_named_argument = { ident ~ ws* ~ default_value }

//`2.0mm`: ok # Positional argument
function_positional_argument = { expression }

function_positional_argument_list = { function_positional_argument ~ (ws* ~ "," ~ ws* ~ (function_named_argument | function_positional_argument))* }
function_named_argument_list = { function_named_argument ~ (ws* ~ "," ~ ws* ~ function_named_argument)* }

//`a = 5.0mm, b = false`: ok
//`4.0mm, a = false`: ok
//`a = false, 4.0mm`: error # Positional argument after named argument
//`a = false, 4.0mm, b = 3.0`: error # Positional argument after named argument
function_argument_list = { function_positional_argument_list ~ ws* ~ "," ~ ws* ~ function_named_argument_list | function_named_argument_list | function_positional_argument_list }

//`function(a = 3.0mm)`: ok
//`function(a = 3.0mm, b = 2.0mm)`: ok
//`a.nested.function(a = 3.0mm, b = 2.0mm)`: ok
function_call = { qualified_name ~ ws* ~ "(" ~ ws* ~ function_argument_list? ~ ws* ~ ")" }

//`r: length = 5.0mm`: ok
//`r = 5.0mm`: ok # Type specifier with type inference
//`r: length`: ok # Default value is not required
//`r: length = math.PI`: ok # Type specifier + Default value from constant
//`r`: error # neither type specifier or default value
variable_declaration = { ident ~ ws* ~ (type_specifier ~ ws* ~ default_value | type_specifier | default_value) }

//`r: length = 5.0mm;`: ok
variable_declaration_statement = { variable_declaration ~ ws* ~ ";" }

//`function foo() -> scalar { return math.PI; }`: ok
//`function foo() -> scalar {}`: error # Function must have a return statement
//`function foo() { return 5.0mm; }`: error # Function must have specified return type
//`function foo(a: scalar) -> scalar { return a; }`: ok # Function with arguments
//`function foo(a: scalar, b: scalar) -> scalar { return b; }`: ok # Function with multiple arguments
function_declaration = { "function" ~ ws+ ~ ident ~ ws* ~ "(" ~ ws* ~ function_declaration_argument_list? ~ ws* ~ ")" ~ ws* ~ function_declaration_return_value ~ ws* ~ "{" ~ ws* ~ statement* ~ ws* ~ function_return_statement ~ ws* ~ "}" }

//`a: scalar`: ok
function_declaration_argument =  { variable_declaration }

//`-> scalar`: ok
function_declaration_return_value = { "->" ~ ws* ~ type }

//`return 5.0mm;`: ok
function_return_statement = { "return" ~ ws* ~ expression ~ ws* ~ ";" }

//`a: scalar, b: scalar`: ok # Multiple arguments
//`a: scalar, b: scalar = 5.0mm`: ok # Default value for second argument
//`a: scalar = 5.0mm, b: scalar`: ok # Even first argument can have default value and rest can be positional
function_declaration_argument_list = { function_declaration_argument ~ ws* ~ ("," ~ ws* ~ function_declaration_argument ~ ws*)* }

//`module foo() { }`: ok # Module with no arguments
//`module foo(a: scalar) { }`: ok # Module with arguments
//`module foo(a: scalar, b: scalar) { }`: ok # Module with multiple arguments
//`module foo() { return 5.0mm; }`: error # Module cannot have return statement
//`module foo() { module bar() { } }`: ok # Nested module
//`module foo() { a: scalar = 5.0; function bar() -> scalar { return 1; } }`: ok # Parameter and nested function
//`module math { }`: ok # Module with no argument list acts as namespace
module_declaration = { "module" ~ ws+ ~ ident ~ ws* ~  
    module_declaration_argument_list? ~
    "{" ~ ws* ~ (statement ~ ws*)* ~ "}" }
module_declaration_argument_list = { ("(" ~ ws* ~ function_declaration_argument_list? ~ ws* ~ ")")? ~ ws* }

//`circle(r = 5.0mm);`: ok
//`circle(r = 5.0mm) {}`: ok
//`translate(x = 5.0mm) { rectangle(width = 5.0); }`: ok
//`translate(x = 5.0mm) { rotate(angle = 90°) { rectangle(width = 5.0mm); } }`: ok
//`translate(r = 5.0mm) circle(r = 5.0mm);`: ok
//`name := node() {}`: ok
//`name := node();`: ok
object_node_statement = { 
    object_node_id_assignment? ~ (function_call ~ ws*)+ ~ ";" |
    object_node_id_assignment? ~ (function_call ~ ws*)+ ~ "{" ~ object_node_inner ~ "}" 
}
object_node_id_assignment = { ident ~ ws* ~ ":=" ~ ws* }
object_node_inner = { ws* ~ (statement ~ ws*)* }

statement = { object_node_statement | use_statement | module_declaration | function_declaration | variable_declaration_statement }

//`translate(x = 5.0mm) { rectangle(width = 5.0mm); } translate(x = 5.0mm) { rotate(angle = 90°) { rectangle(width = 5.0); } }`: ok
document = { SOI ~ (statement ~ ws* )* ~ EOI }

COMMENT = { doc_comment | single_line_comment | multi_line_comment }

//`// ok`: ok
//`/ err` error
single_line_comment = ${ "//" ~ (!"\n" ~ ANY)* }

//`/// ok`: ok
//`// err` error
doc_comment = { "///" ~ (!"\n" ~ ANY)* }

//`/* ok */`: ok
multi_line_comment = ${ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }