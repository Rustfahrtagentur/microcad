// Copyright © 2024 The µcad authors <info@ucad.xyz>
// SPDX-License-Identifier: AGPL-3.0-or-later

//! Generate tests out of *Markdown* files which include µcad code
//!
//! Path will be scanned recursively for *Markdown* files (`*.md`).
//! Code must be marked by *Markdown* code markers (code type: `µcad`) with a test ID attached.
//! In case of a failing test `#fail` must be appended to the test ID.
//!
//! Relative path's of scanned folder names will be used to build a modules structure  
//! in the resulting code.
//! If test IDs include `.` name will be split into several names which will be
//! used to crates sub modules.
use anyhow::{Context, Result};
use walk_path::*;

/// for debugging purpose
#[allow(unused)]
macro_rules! trace {
    ($($tokens: tt)*) => {
        println!("cargo:warning={}", format!($($tokens)*))
    }
}

/// Generate tests from the *Markdown* files which are within the given `path`
///
/// Path will be scanned recursively
pub fn generate(path: impl AsRef<std::path::Path>) -> Result<()> {
    use std::{env::*, path::*};

    // get target path
    let out_dir = var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("microcad_markdown_test.rs");

    // read all *Markdown files into a tree to reorder modules
    let mut wp = WalkPath::new();
    wp.scan(
        path.as_ref(),
        "md",
        &["target", "thirdparty"],
        &scan_for_tests,
    )?;

    let mut code = String::new();

    code += r#"// This code was generated by microcad_markdown_test
        static SEARCH_PATH: &str = "../std";
    "#;

    write(&mut code, &wp);

    match rustfmt_wrapper::rustfmt(code) {
        Ok(code) =>
        // write all rust code at once
        {
            std::fs::write(&dest_path, code)
                .context(format!("cannot create file '{dest_path:?}'"))?;
            Ok(())
        }
        Err(rustfmt_wrapper::Error::Rustfmt(msg)) => {
            Err(anyhow::Error::msg(msg.clone())).context(msg)
        }
        Err(err) => Err(anyhow::Error::new(err)),
    }
}

/// Read single *Markdown* file and collect included tests in `tree`.
///
/// Generates tree nodes if name can be split into several names which are separated by `.`.
fn scan_for_tests(tree: &mut WalkPath<String>, file_path: &std::path::Path) -> Result<bool> {
    use regex::*;
    use std::{fs::*, io::*};

    // load markdown file
    let mut md_content = String::new();
    {
        File::open(file_path)?.read_to_string(&mut md_content)?;
    }

    // match markdown code markers for µcad
    let reg = Regex::new(r#"```µ[Cc][Aa][Dd](,(?<name>[\.#\w]+))?[\r\n]+(?<code>[^`]*)+```"#)
        .expect("bad regex");

    let module_path = file_path
        .iter()
        .filter(|f| f.to_str() != Some(".."))
        .map(|f| f.to_str().unwrap().trim_end_matches(".md"))
        .collect::<Vec<&str>>()
        .join(".");

    let mut result = true;
    for cap in reg.captures_iter(&md_content) {
        // check if code is named

        if let (Some(code), Some(name)) = (cap.name("code"), cap.name("name")) {
            insert(
                tree,
                &[&module_path, name.as_str()].join("."),
                code.as_str().to_string(),
            );
            result = false;
        }
    }

    Ok(result)
}

/// insert new test code by module path
/// - `path`: list of nested rust module names separated by `.`
/// - `code`: µcad test code
fn insert(wp: &mut WalkPath<String>, path: &str, code: String) {
    use std::{cell::RefCell, rc::Rc};

    if let Some((path, crumbs)) = path.split_once('.') {
        match wp {
            WalkPath::Root(ref mut children) | WalkPath::Dir(_, ref mut children) => {
                if let Some(ref mut file) = children.get(std::path::Path::new(path)) {
                    insert(&mut file.borrow_mut(), crumbs, code);
                } else {
                    _ = children.insert(path.into(), {
                        let mut new = WalkPath::Dir(path.into(), Dir::<String>::new());
                        // recursively fill module
                        insert(&mut new, crumbs, code);
                        Rc::new(RefCell::new(new))
                    })
                }
            }
            _ => unreachable!(),
        }
    } else {
        match wp {
            WalkPath::Dir(_, ref mut children) | WalkPath::Root(ref mut children) => {
                _ = children.insert(
                    path.into(),
                    Rc::new(RefCell::new(WalkPath::File(path.into(), code))),
                )
            }
            _ => unreachable!(),
        }
    }
}

fn write(f: &mut String, wp: &WalkPath<String>) {
    match wp {
        WalkPath::Root(children) => {
            for child in children {
                f.push_str(
                    "// This code was generated by microcad_markdown_test
                    
                    ",
                );
                write(f, &child.1.as_ref().borrow());
            }
        }
        WalkPath::Dir(name, children) => {
            let name = name.to_str().unwrap();
            f.push_str(&format!(
                "mod r#{name} {{
                #![allow(non_snake_case)]
                
            "
            ));
            for child in children {
                write(f, &child.1.as_ref().borrow());
            }
            f.push_str("}\n\n");
        }
        WalkPath::File(name, code) => write_code(f, name.to_str().unwrap(), code),
    }
}

fn write_code(f: &mut String, name: &str, code: &str) {
    let (name, suffix) = if let Some((name, suffix)) = name.split_once('#') {
        (name, Some(suffix))
    } else {
        (name, None)
    };
    // Early exit for "#no_test" and "#todo" suffixes
    if suffix == Some("no_test") || suffix == Some("todo") {
        return;
    }
    f.push_str(
    &format!(
        r##"#[test]
            fn r#{name}() {{
                microcad_lang::env_logger_init();
                use microcad_lang::parse::*;
                use microcad_std::*;
                use crate::SEARCH_PATH;
                match SourceFile::load_from_str(
                    r#"
                    {code}"#,
                ) {handling};
            }}"##,
        handling = match suffix {
            Some("fail") =>
                r##"{
                        Err(err) => log::debug!("{err}"),
                        Ok(source) => { 
                            let mut context = ContextBuilder::new(source).with_std(SEARCH_PATH).build();
                            
                            if let Err(err) = context.eval() {
                                log::debug!("{err}");
                            } else {
                                if context.diag().error_count > 0 {
                                    let mut w = std::io::stdout();
                                    context.diag().pretty_print(&mut w, &context).unwrap();
                                } else {
                                    panic!("ERROR: test is marked to fail but succeeded");
                                }

                            }
                        }
                    }"##,
            _ =>
                r##"{
                        Ok(source) => {
                            let mut context = ContextBuilder::new(source).with_std(SEARCH_PATH).build();
                            
                            if let Err(err) = context.eval() {
                                panic!("{err}");
                            } else {
                                if context.diag().error_count > 0 {
                                    let mut w = std::io::stderr();
                                    context.diag().pretty_print(&mut w, &context).unwrap();
                                    panic!("ERROR: there were {error_count} errors", error_count = context.diag().error_count);
                                }
                                log::trace!("test succeeded");
                            }
                        },
                        Err(err) => panic!("ERROR: {err}"),
                    }"##,
        }
    )
);
}
