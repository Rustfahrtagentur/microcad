// Copyright © 2024 The µCAD authors <info@ucad.xyz>
// SPDX-License-Identifier: AGPL-3.0-or-later

//! Generate tests for each µcad files in the `test_cases` folder

#![warn(missing_docs)]

use anyhow::{Context, Result};
use walk_path::*;

fn write(f: &mut String, wp: &WalkPath<String>) {
    match wp {
        WalkPath::Root(children) => {
            f.push_str(
                "// This code was generated by microcad_test_generator

                ",
            );

            for child in children {
                write(f, &child.1.as_ref().borrow());
            }
        }

        WalkPath::Dir(name, children) => {
            let name = name.to_str().unwrap();
            f.push_str(&format!(
                "mod r#{name} {{
                    #![allow(non_snake_case)]
                    
                "
            ));
            for child in children {
                write(f, &child.1.as_ref().borrow());
            }

            f.push_str("}\n\n");
        }
        WalkPath::File(name, code) => {
            let name = name.to_str().unwrap();

            f.push_str(&format!(
                r##"#[test]
                        fn r#{name}() {{
                            {code}
                        }}"##,
            ));
        }
    }
}

/// insert new test code by module path
/// - `path`: list of nested rust module names separated by `.`
/// - `code`: µCAD test code
fn insert(wp: &mut WalkPath<String>, path: &str, code: String) {
    use std::{cell::RefCell, rc::Rc};

    match wp {
        WalkPath::Dir(_, ref mut children) | WalkPath::Root(ref mut children) => {
            _ = children.insert(
                path.into(),
                Rc::new(RefCell::new(WalkPath::File(path.into(), code))),
            )
        }
        _ => unreachable!(),
    }
}

pub fn generate(path: impl AsRef<std::path::Path>) -> Result<()> {
    use std::{env::*, path::*};

    // get target path
    let out_dir = var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("microcad_source_file_test.rs");

    let mut wp = WalkPath::new();
    let mut code = String::new();

    wp.scan(path.as_ref(), "µcad", &|tree, file_path| {
        println!("{file_path:?}");
        insert(
            tree,
            file_path.file_stem().unwrap().to_str().unwrap(),
            "/* test code */".into(),
        );
        Ok(true)
    })?;

    write(&mut code, &wp);

    match rustfmt_wrapper::rustfmt(code) {
        Ok(code) =>
        // write all rust code at once
        {
            std::fs::write(&dest_path, code)
                .context(format!("cannot create file '{dest_path:?}'"))?;
            Ok(())
        }
        Err(rustfmt_wrapper::Error::Rustfmt(msg)) => {
            Err(anyhow::Error::msg(msg.clone())).context(msg)
        }
        Err(err) => Err(anyhow::Error::new(err)),
    }
}

#[test]
fn generate_source_file_tests() {
    std::env::set_var("OUT_DIR", "..");
    generate("../test_cases").unwrap();
}
