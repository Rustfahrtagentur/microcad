pub use __builtin::ops::difference;
pub use __builtin::ops::intersection;
pub use __builtin::ops::union;
pub use __builtin::ops::hull;


op revolve(angle = 360°) {
    @children.__builtin::ops::revolve(
        circular_segments = 64, // TODO: Make this adaptive to resolution 
        revolve_degrees = angle / 1°
    );
}

op extrude(height: Length) {
    @children.__builtin::ops::extrude(height = height / 1mm, n_divisions = 0, twist_degrees = 0.0, scale_top_x = 1.0, scale_top_y = 1.0);
}

op translate(x = 0.0mm, y = 0.0mm, z = 0.0mm) {
	@children.__builtin::ops::translate(x = x / 1mm, y = y / 1mm, z = z / 1mm);
}

/// A transformer that rotates a part.
///
/// See the `init`s for examples on how to use this transformer. 
op rotate(matrix: Matrix3) {
	/// Rotate around an axis by an angle using a 3D vector.
	/// 
	/// The `axis` vector will be normalized. 
	///
	/// * `angle` - An angle.
	/// * `axis` - An axis to rotate around (Z axis is default).
	///
	/// Examples:
	/// * `rect(42mm).rotate(45°);`: 2D rotation of a square by 45°.
	/// * `cube(42mm).rotate(45°, (x = 1, y = 1, z = 1));`: Rotates a cube by 45° around a diagonal axis.
	/// * `cube(42mm).rotate(30°, Y);`: Rotates a cube by 30° around Y axis.
	init(angle: Angle, axis = __builtin::math::Z) {
		matrix = __builtin::math::rotate_around_axis(angle, x = axis.x, y = axis.y, z = axis.z);
	}
	
	/// Euler rotation around X, Y, Z.
	///
	/// * `x` - X angle.
	/// * `y` - Y angle.
	/// * `z` - Z angle.
	///
	/// Examples:
	/// * `cube(42mm).rotate(x = 45°);`: Rotates a cylinder by 45° around X axis (unnamed tuple).
	init(x = 0°, y = 0°, z = 0°) {
		matrix = __builtin::math::rotate_xyz(x, y, z);		
	}
	
	/// Euler rotation around X, Y, Z (nautical angles)
	///
	/// * `roll` - Roll angle, rotates around X axis.
	/// * `pitch` - Pitch angle, rotates around Y axis.
	/// * `yaw` - Yaw angle, rotates around Z axis.
	///
	/// Example:
	/// * `cube(42mm).rotate(roll = 30°)`: Rotates a cylinder by 45° around X axis.
	init(roll = 0°, pitch = 0°, yaw = 0°) {
		matrix = __builtin::math::rotate_xyz(roll, pitch, yaw);
	}
	
	/// Euler rotation around X, Y and Z axis (with a vector of angles)
	///
	/// * `cube(42mm).rotate(xyz = (30°,20°,10°))`: Euler rotation for a cube around X, Y, Z axis.
	init(xyz = (x = 0°,y = 0°,z = 0°)) {
		matrix = __builtin::math::rotate_xyz(xyz.x, xyz.y, xyz.z);
	}
	
	/// Euler rotation around Z, Y and X axis (with a vector of angles)
	///
	/// * `cube(42mm).rotate(zyx = (30°,20°,10°))`: Euler rotation for a cube around Z, Y, X axis.
	init(zyx = (x = 0°, y = 0°, z = 0°)) {
		matrix = __builtin::math::rotate_zyx(zyx.z, zyx.y, zyx.x);
	}

	@children.__builtin::ops::rotate(matrix);
}


/// Orient an object towards a vector.
op orient(v: Vec3) {
    @children.__builtin::ops::orient(x = v.x, y = v.y, z = v.z);
}

/// Positions child objects using polar coordinates around the Z axis.
///
/// This operator places each child at a specified polar coordinate,
/// converting an angle and radius into a cartesian transformation.
/// An optional `shift` moves the object perpendicular to the radius direction
/// (i.e., along the local Y-axis after rotation).
///
/// # Parameters
/// - `angle`: The polar angle (in degrees or radians depending on context) from the positive X-axis.
/// - `radius`: Distance from the origin along the direction of the angle.
/// - `shift`: Optional distance to shift along the local Y-axis after rotation.
///            Defaults to `0.0mm`, meaning no shift.
op polar(angle: Angle, radius: Length, shift: Length = 0.0mm) {
    @children.translate(x = radius, y = shift).rotate(angle);
}
